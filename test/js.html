<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础面试题 | MrZhao&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/assets/logo.jpg">
    <meta name="description" content="个人博客">
    
    <link rel="preload" href="/assets/css/0.styles.ddf5beda.css" as="style"><link rel="preload" href="/assets/js/app.acb235b1.js" as="script"><link rel="preload" href="/assets/js/2.d372d77b.js" as="script"><link rel="preload" href="/assets/js/1.37fa4b6c.js" as="script"><link rel="preload" href="/assets/js/98.b1d996fc.js" as="script"><link rel="prefetch" href="/assets/js/10.82b2071b.js"><link rel="prefetch" href="/assets/js/100.e63403ed.js"><link rel="prefetch" href="/assets/js/101.f5129fd2.js"><link rel="prefetch" href="/assets/js/102.d0ddf2d8.js"><link rel="prefetch" href="/assets/js/103.9926bfcb.js"><link rel="prefetch" href="/assets/js/104.af476e27.js"><link rel="prefetch" href="/assets/js/105.c8937ef6.js"><link rel="prefetch" href="/assets/js/106.1397eb8d.js"><link rel="prefetch" href="/assets/js/107.9afde75e.js"><link rel="prefetch" href="/assets/js/108.cb71564c.js"><link rel="prefetch" href="/assets/js/109.367dbeed.js"><link rel="prefetch" href="/assets/js/11.4dba772f.js"><link rel="prefetch" href="/assets/js/110.49f4bab3.js"><link rel="prefetch" href="/assets/js/111.5d4c672e.js"><link rel="prefetch" href="/assets/js/112.edc0db73.js"><link rel="prefetch" href="/assets/js/113.9852316c.js"><link rel="prefetch" href="/assets/js/114.ffe9fe06.js"><link rel="prefetch" href="/assets/js/115.564724ca.js"><link rel="prefetch" href="/assets/js/116.5cd792a1.js"><link rel="prefetch" href="/assets/js/117.4b4aaf18.js"><link rel="prefetch" href="/assets/js/118.6888441c.js"><link rel="prefetch" href="/assets/js/119.b8950c5c.js"><link rel="prefetch" href="/assets/js/12.27965b5f.js"><link rel="prefetch" href="/assets/js/120.c92b4b7a.js"><link rel="prefetch" href="/assets/js/121.0d5986c2.js"><link rel="prefetch" href="/assets/js/122.e54d395a.js"><link rel="prefetch" href="/assets/js/123.7de3e59a.js"><link rel="prefetch" href="/assets/js/124.aec1c47d.js"><link rel="prefetch" href="/assets/js/125.12be05e6.js"><link rel="prefetch" href="/assets/js/13.4895e118.js"><link rel="prefetch" href="/assets/js/14.efee2099.js"><link rel="prefetch" href="/assets/js/15.08f58c28.js"><link rel="prefetch" href="/assets/js/16.e25cce72.js"><link rel="prefetch" href="/assets/js/17.73af3b17.js"><link rel="prefetch" href="/assets/js/18.a5cd26c5.js"><link rel="prefetch" href="/assets/js/19.5b5def25.js"><link rel="prefetch" href="/assets/js/20.9ae07869.js"><link rel="prefetch" href="/assets/js/21.1f0d465b.js"><link rel="prefetch" href="/assets/js/22.0e74832d.js"><link rel="prefetch" href="/assets/js/23.7d3158db.js"><link rel="prefetch" href="/assets/js/24.83abb9ba.js"><link rel="prefetch" href="/assets/js/25.c853c4de.js"><link rel="prefetch" href="/assets/js/26.e4ede223.js"><link rel="prefetch" href="/assets/js/27.3b00c66b.js"><link rel="prefetch" href="/assets/js/28.123c02f0.js"><link rel="prefetch" href="/assets/js/29.981e7943.js"><link rel="prefetch" href="/assets/js/3.5e61bf8f.js"><link rel="prefetch" href="/assets/js/30.47d8c561.js"><link rel="prefetch" href="/assets/js/31.b0370337.js"><link rel="prefetch" href="/assets/js/32.f5639ab2.js"><link rel="prefetch" href="/assets/js/33.4d982e7e.js"><link rel="prefetch" href="/assets/js/34.476ca9ee.js"><link rel="prefetch" href="/assets/js/35.d6c54e1c.js"><link rel="prefetch" href="/assets/js/36.bb6f614a.js"><link rel="prefetch" href="/assets/js/37.a8ecfac1.js"><link rel="prefetch" href="/assets/js/38.e7d16fe5.js"><link rel="prefetch" href="/assets/js/39.7dc7f49e.js"><link rel="prefetch" href="/assets/js/4.30f14711.js"><link rel="prefetch" href="/assets/js/40.d05cfc3c.js"><link rel="prefetch" href="/assets/js/41.38899e70.js"><link rel="prefetch" href="/assets/js/42.0b533d65.js"><link rel="prefetch" href="/assets/js/43.53d193d3.js"><link rel="prefetch" href="/assets/js/44.3b96fad7.js"><link rel="prefetch" href="/assets/js/45.eef657e9.js"><link rel="prefetch" href="/assets/js/46.b2f1fd36.js"><link rel="prefetch" href="/assets/js/47.9c09556d.js"><link rel="prefetch" href="/assets/js/48.ce176bc3.js"><link rel="prefetch" href="/assets/js/49.f55f1fca.js"><link rel="prefetch" href="/assets/js/5.756b6e8a.js"><link rel="prefetch" href="/assets/js/50.beb1776a.js"><link rel="prefetch" href="/assets/js/51.d31795c1.js"><link rel="prefetch" href="/assets/js/52.19761715.js"><link rel="prefetch" href="/assets/js/53.cf691bec.js"><link rel="prefetch" href="/assets/js/54.69111173.js"><link rel="prefetch" href="/assets/js/55.6a5031d0.js"><link rel="prefetch" href="/assets/js/56.a6d0b60c.js"><link rel="prefetch" href="/assets/js/57.9a437f90.js"><link rel="prefetch" href="/assets/js/58.8f3c8e43.js"><link rel="prefetch" href="/assets/js/59.dc73bd90.js"><link rel="prefetch" href="/assets/js/6.c6e8dcba.js"><link rel="prefetch" href="/assets/js/60.8431e9e8.js"><link rel="prefetch" href="/assets/js/61.31a7a75b.js"><link rel="prefetch" href="/assets/js/62.a78d06bf.js"><link rel="prefetch" href="/assets/js/63.b40afbd7.js"><link rel="prefetch" href="/assets/js/64.cb8ba378.js"><link rel="prefetch" href="/assets/js/65.608bc3be.js"><link rel="prefetch" href="/assets/js/66.c430f2d9.js"><link rel="prefetch" href="/assets/js/67.96a5041b.js"><link rel="prefetch" href="/assets/js/68.d152d1b8.js"><link rel="prefetch" href="/assets/js/69.54bd8d5c.js"><link rel="prefetch" href="/assets/js/7.b18f4475.js"><link rel="prefetch" href="/assets/js/70.d10c0bb6.js"><link rel="prefetch" href="/assets/js/71.1b530077.js"><link rel="prefetch" href="/assets/js/72.76b37ee5.js"><link rel="prefetch" href="/assets/js/73.1d72d0ea.js"><link rel="prefetch" href="/assets/js/74.136395b3.js"><link rel="prefetch" href="/assets/js/75.163b827e.js"><link rel="prefetch" href="/assets/js/76.29c6b42d.js"><link rel="prefetch" href="/assets/js/77.ce9ee614.js"><link rel="prefetch" href="/assets/js/78.299f9cda.js"><link rel="prefetch" href="/assets/js/79.fe755e03.js"><link rel="prefetch" href="/assets/js/80.1884cea8.js"><link rel="prefetch" href="/assets/js/81.68edf7ac.js"><link rel="prefetch" href="/assets/js/82.a4b444d1.js"><link rel="prefetch" href="/assets/js/83.055b0579.js"><link rel="prefetch" href="/assets/js/84.6d10a5cc.js"><link rel="prefetch" href="/assets/js/85.56cc70f5.js"><link rel="prefetch" href="/assets/js/86.46400f67.js"><link rel="prefetch" href="/assets/js/87.0e8035e0.js"><link rel="prefetch" href="/assets/js/88.e86cd82a.js"><link rel="prefetch" href="/assets/js/89.1115943f.js"><link rel="prefetch" href="/assets/js/90.1ec59b21.js"><link rel="prefetch" href="/assets/js/91.92c56bfd.js"><link rel="prefetch" href="/assets/js/92.98f06763.js"><link rel="prefetch" href="/assets/js/93.efccb64b.js"><link rel="prefetch" href="/assets/js/94.bd47fc37.js"><link rel="prefetch" href="/assets/js/95.1aedc256.js"><link rel="prefetch" href="/assets/js/96.f7ec82ea.js"><link rel="prefetch" href="/assets/js/97.1903528c.js"><link rel="prefetch" href="/assets/js/99.a7062bf9.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.cc58001a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ddf5beda.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">MrZhao's blog</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feBase/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/ES6/base.html" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/feBase/css/1.html" class="nav-link">
  Css
</a></li><li class="dropdown-item"><!----> <a href="/feBase/browser/1.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/feBase/mini/1.html" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/react/1.html" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/ssr/" class="nav-link">
  SSR
</a></li><li class="dropdown-item"><!----> <a href="/cloudflare/tunnel.html" class="nav-link">
  Cloudflare
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><span class="title">打包工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="打包工具" class="mobile-dropdown-title"><span class="title">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/base.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/rollup/base.html" class="nav-link">
  Rollup
</a></li></ul></div></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/leetcode/array.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/test/" class="nav-link router-link-active">
  常见问题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feBase/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/ES6/base.html" class="nav-link">
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/feBase/css/1.html" class="nav-link">
  Css
</a></li><li class="dropdown-item"><!----> <a href="/feBase/browser/1.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/feBase/mini/1.html" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/react/1.html" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/ssr/" class="nav-link">
  SSR
</a></li><li class="dropdown-item"><!----> <a href="/cloudflare/tunnel.html" class="nav-link">
  Cloudflare
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><span class="title">打包工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="打包工具" class="mobile-dropdown-title"><span class="title">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/base.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/rollup/base.html" class="nav-link">
  Rollup
</a></li></ul></div></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/leetcode/array.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/test/" class="nav-link router-link-active">
  常见问题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>常见问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/" aria-current="page" class="sidebar-link">常用技巧总结</a></li><li><a href="/test/js.html" aria-current="page" class="active sidebar-link">JS基础面试题</a></li><li><a href="/test/vue.html" class="sidebar-link">Vue面试题</a></li><li><a href="/test/react.html" class="sidebar-link">React面试题</a></li><li><a href="/test/write.html" class="sidebar-link">手写面试题</a></li><li><a href="/test/project.html" class="sidebar-link">项目常用</a></li><li><a href="/test/binaryTree.html" class="sidebar-link">二叉树</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#_1-2-10-map-parseint">['1', '2', '10'].map(parseInt)</a></li><li><a href="#settimeout、promise、async-await-的区别">setTimeout、Promise、async/await 的区别</a><ul><li><a href="#settimeout">setTimeout</a></li><li><a href="#promise">Promise</a></li><li><a href="#async-await">async/await</a></li></ul></li><li><a href="#js异步解决方案的发展历程以及优缺点">JS异步解决方案的发展历程以及优缺点</a><ul><li><a href="#回调函数">回调函数</a></li><li><a href="#promise">Promise</a></li><li><a href="#async-await">Async/await</a></li></ul></li><li><a href="#es5-es6-的继承除了写法以外还有什么区别">ES5/ES6 的继承除了写法以外还有什么区别</a></li><li><a href="#事件循环在浏览器和-node-中的区别">事件循环在浏览器和 node 中的区别</a></li><li><a href="#模块化进程">模块化进程</a></li><li><a href="#doctype-的作用">DOCTYPE 的作用</a></li><li><a href="#兼容模式和标准模式的区别">兼容模式和标准模式的区别</a></li><li><a href="#为什么html5不需要dtd">为什么HTML5不需要DTD？</a></li><li><a href="#前端性能优化">前端性能优化</a><ul><li><a href="#页面内容方面">页面内容方面</a></li><li><a href="#服务器方面">服务器方面</a></li></ul></li><li><a href="#精度丢失问题">精度丢失问题</a></li><li><a href="#script标签阻塞页面加载">script标签阻塞页面加载</a></li><li><a href="#css阻塞页面加载么">css阻塞页面加载么？</a></li><li><a href="#es6解构赋值、默认值">ES6解构赋值、默认值</a></li><li><a href="#滚动条滚动会导致回流么">滚动条滚动会导致回流么？</a></li><li><a href="#服务端渲染原理">服务端渲染原理</a></li><li><a href="#移动端实现1px">移动端实现1px</a></li><li><a href="#vue中运行时和完整版的区别">vue中运行时和完整版的区别</a></li><li><a href="#xss攻击">XSS攻击</a></li></ul></div><p></p> <h1 id="js基础面试题"><a href="#js基础面试题" class="header-anchor">#</a> JS基础面试题</h1> <h2 id="_1-2-10-map-parseint"><a href="#_1-2-10-map-parseint" class="header-anchor">#</a> <code>['1', '2', '10'].map(parseInt)</code></h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>输出结果<code>[1,NaN,2]</code> <code>parseInt(str,n)</code>
把第一个参数看作是一个数的<code>n</code>进制的表示，而返回的数值则是十进制；
如<code>parseInt('123',5);</code>将'123'当做5进制的数，返回十进制 <code>1 * 5^2 + 2 * 5^1 + 3 * 5^0 = 38</code>
如果第一个参数中不存在n进制的表示数字，则返回能解析的部分，<code>parseInt('15',2) = 1</code></p></div> <h2 id="settimeout、promise、async-await-的区别"><a href="#settimeout、promise、async-await-的区别" class="header-anchor">#</a> <code>setTimeout、Promise、async/await</code> 的区别</h2> <h3 id="settimeout"><a href="#settimeout" class="header-anchor">#</a> <code>setTimeout</code></h3> <p><code>setTimeout</code>的回调函数是放到宏任务队列里;（等到执行栈清空后执行）</p> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> <code>Promise</code></h3> <blockquote><p><code>Promise</code>本身执行时是同步的，<code>then</code>产生的回调函数是放到微任务队列里</p></blockquote> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> <code>async/await</code></h3> <blockquote><p><code>async</code>函数表示函数里可能会有异步的方法，<code>await</code>后面跟一个表达式，<code>async</code>方法执行时，遇到<code>await</code>会立即执行<code>await</code>后面的表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p></blockquote> <h2 id="js异步解决方案的发展历程以及优缺点"><a href="#js异步解决方案的发展历程以及优缺点" class="header-anchor">#</a> JS异步解决方案的发展历程以及优缺点</h2> <h3 id="回调函数"><a href="#回调函数" class="header-anchor">#</a> 回调函数</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><em>优点</em></p> <ul><li>1、解决了同步问题</li></ul> <p><em>缺点</em></p> <ul><li>缺乏顺序性：回调地域导致的调试困难</li> <li>嵌套函数耦合性高；</li> <li>嵌套过多很难处理错误</li> <li>不能<code>return</code></li></ul></div> <h3 id="promise-2"><a href="#promise-2" class="header-anchor">#</a> <code>Promise</code></h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><em>优点</em></p> <ul><li>1、解决了回调地狱的问题</li></ul> <p><em>缺点</em></p> <ul><li>一旦开始就无法取消</li> <li>不知道内部进行到哪个阶段</li> <li>错误需要通过回调函数来捕获</li></ul></div> <h3 id="async-await-2"><a href="#async-await-2" class="header-anchor">#</a> <code>Async/await</code></h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>终极的异步解决方案</p> <p><em>优点</em></p> <ul><li>代码清晰，处理了地域回调的问题</li></ul> <p><em>缺点</em></p> <ul><li><code>await</code>将异步变同步，多个异步操作如果没有依赖关系，使用<code>await</code>会导致性能下降</li></ul></div> <h2 id="es5-es6-的继承除了写法以外还有什么区别"><a href="#es5-es6-的继承除了写法以外还有什么区别" class="header-anchor">#</a> <code>ES5/ES6</code> 的继承除了写法以外还有什么区别</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><em>继承的机制不同</em></p> <ul><li><code>ES5</code>：先生成子类的实例，再调用父类的构造函数修饰子类的实例，由于父类的内置属性无法获取，导致无法继承原生的构造函数。（比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。）</li> <li><code>ES6</code>：先生成父类的实例，再调用子类的构造函数修饰生成的实例。由于这个差异，使得<code>ES6</code>继承可以继承内置对象。</li></ul></div> <h2 id="事件循环在浏览器和-node-中的区别"><a href="#事件循环在浏览器和-node-中的区别" class="header-anchor">#</a> 事件循环在浏览器和 <code>node</code> 中的区别</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>浏览器中：</p> <ul><li>执行所有<code>同步js代码</code> → 执行所有<code>微任务</code>→<code>渲染页面</code>→执行一个<code>宏任务</code>→执行宏任务产生的<code>微任务</code>→渲染页面→执行下一个<code>宏任务</code>→执行宏任务产生的<code>微任务</code>→循环……</li></ul> <p>node中：</p> <ul><li><code>timers</code> 阶段：这个阶段执行 <code>timer（setTimeout、setInterval）</code>的回调</li> <li><code>I/O callbacks</code> 阶段：处理一些上一轮循环中的少数未执行的 <code>I/O</code>回调</li> <li><code>idle, prepare</code> 阶段：仅 <code>node</code> 内部使用</li> <li><code>poll</code> 阶段：获取新的 <code>I/O</code> 事件, 适当的条件下 <code>node</code> 将阻塞在这里</li> <li><code>check</code> 阶段：执行 <code>setImmediate()</code> 的回调</li> <li><code>close callbacks</code> 阶段：执行 <code>socket</code> 的 <code>close</code> 事件回调</li></ul> <p>上面六个阶段都不包括 <code>process.nextTick()</code></p> <ul><li>node10以前
<ul><li>执行一个阶段的所有任务→执行完<code>nextTick</code>队列里的任务→执行所有的<code>微任务</code></li></ul></li></ul> <img src="/assets/test-node-1.png" alt="test-node-1"> <ul><li>node11以后
<ul><li>和浏览器做了统一</li></ul></li></ul></div> <h2 id="模块化进程"><a href="#模块化进程" class="header-anchor">#</a> 模块化进程</h2> <blockquote><p><code>IIFE</code>：最开始采用自执行函数形成私有作用域来编写模块化，避免变量冲突</p> <p><code>AMD</code>：采用<code>requireJs</code>编写模块化，特点：必须提前进行声明</p> <p><code>CMD</code>：采用<code>Sea.js</code>来编写模块化，特点：可以动态导入模块</p> <p><code>CommonJS</code>：<code>nodeJS</code>中自带的模块化（<code>require</code>的导入方式）</p> <p><code>UMD</code>：兼容<code>AMD</code>,<code>CommonJS</code>模块化语法；</p> <p><code>ES6 Modules</code>：<code>ES6</code>引入的模块化，支持<code>import</code>导入另一个<code>JS</code></p></blockquote> <h2 id="doctype-的作用"><a href="#doctype-的作用" class="header-anchor">#</a> <code>DOCTYPE</code> 的作用</h2> <blockquote><p>告诉浏览器的解析器，用什么文档标准来解析文档。如果<code>DOCTYPE</code>不存在或者格式不正确，文档将以兼容模式呈现。</p></blockquote> <h2 id="兼容模式和标准模式的区别"><a href="#兼容模式和标准模式的区别" class="header-anchor">#</a> 兼容模式和标准模式的区别</h2> <blockquote><p>标准模式的渲染方式和<code>JS</code>引擎的解析方式都以该浏览器最新的标准去运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防站点无法工作。</p></blockquote> <h2 id="为什么html5不需要dtd"><a href="#为什么html5不需要dtd" class="header-anchor">#</a> 为什么HTML5不需要DTD？</h2> <blockquote><p><code>DTD</code>的作用是用来定义文档中的规则。因为<code>HTML5</code>以前都是基于<code>SGML</code>的，所以需要通过制定<code>DTD</code>来制定文档的规则。而<code>HTML5</code>不是基于<code>SGML</code>的，所以不需要<code>DTD</code>；</p></blockquote> <h2 id="前端性能优化"><a href="#前端性能优化" class="header-anchor">#</a> 前端性能优化</h2> <h3 id="页面内容方面"><a href="#页面内容方面" class="header-anchor">#</a> 页面内容方面</h3> <div class="custom-block tip"><p class="custom-block-title">页面内容</p> <ul><li>1、使用<code>CSS</code>雪碧图、图片小于<code>1M</code>时，使用<code>base64</code>来减少<code>HTTP</code>请求，避免请求过多。</li> <li>2、通过设置缓存策略，对常用不变的资源进行缓存</li> <li>3、非必要资源采用延迟加载的方式来请求。</li> <li>4、使用代码移除（<code>Tree-shaking</code>），作用域提升（<code>Scope hoisting</code>）和代码分割（<code>Code-splitting</code>）来减少有效负载；</li></ul></div> <h3 id="服务器方面"><a href="#服务器方面" class="header-anchor">#</a> 服务器方面</h3> <div class="custom-block tip"><p class="custom-block-title">服务器</p> <ul><li>1、使用<code>CDN</code>服务，来提高用户对于资源的请求速度</li> <li>2、服务器开启<code>Gzip、Deflate</code>等方式对于传输的资源进行压缩，减小文件体积</li> <li>3、尽可能减少<code>cookie</code>的大小，并且通过将静态资源分配到非主域名下，来避免请求静态资源时携带不必要的<code>Cookie</code>（也叫<code>cookie</code>隔离）</li></ul></div> <h2 id="精度丢失问题"><a href="#精度丢失问题" class="header-anchor">#</a> 精度丢失问题</h2> <div class="custom-block tip"><p class="custom-block-title">0.1 + 0.2 === 0.3</p> <p>为什么0.1 + 0.2 === 0.3 在<code>JS</code>中运算结果为<code>false</code>?
<code>JS</code>使用<code>Number</code>类型表示数字（整数和浮点数），遵循 IEEE754 标准，适用64位固定长度来表示，也就是标准的double双精度浮点数，</p> <ul><li>1  ：符号位，0表示正数，1表示负数</li> <li>11 ：指数位（e）</li> <li>52 : 尾数，小数点后面的部分（即有效数字）
这样的存储结构的好处在于可以统一的处理整数和小数，节省存储空间</li></ul> <p>在运算时， 十进制的 0.1 和 0.2 会被转换成二进制的双精度浮点数，转换后会无限循环。由于IEEE754 的尾数限制最多52位，需要将超出的部分截掉，截取采用0舍1入的原则。</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token number">0.00011001100110011001100110011001100110011001100110011010</span>
  <span class="token operator">+</span><span class="token number">0.00110011001100110011001100110011001100110011001100110100</span>
  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
  <span class="token operator">=</span><span class="token number">0.01001100110011001100110011001100110011001100110011001110</span>
</code></pre></div><p>这样在进制的转换中，精度已经丢失，所以相加之后会出现偏差，这就是精度丢失的根本原因。再转换为二进制也就不为0.3了</p> <p>解决方法：</p> <ul><li>1、ES6在<code>Number</code>对象上新增了一个极小的常量 <code>Number.EPSILON</code>，可以用此常量为浮点数设置一个误差范围，只要误差小于<code>Number.EPSILON</code>，我们就可以认为结果是可靠的</li> <li>2、将小数放大为整数（乘10的N次方），然后进行算术运算，最后再缩小为小数(除法)</li> <li>3、使用第三方库如math.js、big.js</li></ul></div> <h2 id="script标签阻塞页面加载"><a href="#script标签阻塞页面加载" class="header-anchor">#</a> script标签阻塞页面加载</h2> <div class="custom-block tip"><p class="custom-block-title">script阻塞</p> <p>普通的<code>script</code>脚本(不带<code>defer、async</code>属性)，会阻塞页面的解析，当解析到普通的<code>script</code>外部脚本时，会等待<code>script</code>脚本下载并执行完毕之后，才会继续解析<code>HTML</code>。但是可以加上<code>defer 或 async</code>属性，这样脚本就都变成了异步下载，不会阻塞页面的解析。只是根据属性不同，执行的时机不同。</p> <p><code>async</code>：异步下载完成之后就立即执行（根据下载完成事件执行，所以顺序会有问题）。执行时会阻塞页面的解析。
<code>defer</code>：延迟到页面解析完成之后，<code>DOMContentLoaded</code>事件之前按照顺序执行完成（实际可能不按顺序，而且不在<code>DOMContentLoaded</code>事件之前执行完）。</p> <p><strong>async</strong>
（高程4解析）
<code>async(HTML5)</code>：异步执行脚本（只对外部脚本文件有效）
添加了<code>defer</code>属性的<code>script</code>外部脚本，表示立刻开始下载脚本，能够异步的加载脚本，而且不会阻塞页面的加载。但是一旦下载完成就会立刻执行，执行时会阻塞页面的加载，所以异步脚本不应该在加载期间修改<code>DOM</code>。而且很可能不会按照原本的顺序执行。
异步脚本保证会在页面<code>load</code>时间之前执行，但可能会在<code>DOMContentLoaded(DOM结构加载完成)</code>事件之前或之后执行。</p> <p>情况一：<code>HTML</code>未解析完，<code>async</code>脚本已经加载完成，<code>HTML</code>停止解析，去执行脚本，脚本执行完毕后，<code>HTML</code>继续解析。<code>HTML</code>解析完成后触发<code>DOMContentLoaded</code>事件。
<img src="/assets/test-async1.png" alt="test-async1"></p> <p>情况二：<code>HTML</code>解析完成后，<code>async</code>脚本才加载完成，然后执行脚本。在<code>HTML</code>解析完成后就触发了<code>DOMContentLoaded</code>事件。
<img src="/assets/test-async2.png" alt="test-async2"></p> <p><strong>defer</strong></p> <p><code>defer(HTML4.01)</code>：推迟执行脚本（只对外部脚本文件有效）
遇到带有<code>defer</code>属性的<code>script</code>外部脚本，会立即下载，但是只会在浏览器解析到结束的<code>&lt;/html&gt;</code>标签后才会按照顺序执行，并且都会在 <code>DOMContentLoaded</code>事件之前执行（实际不一定按照顺序执行或在<code>DOMContentLoaded(DOM结构加载完成)</code>事件之前执行，因此最好只包含一个这样的脚本）
这个属性表示脚本在执行的时候不会改变页面的结构。也就是说脚本会被延迟到文档完全被解析和显示后再执行。设置了<code>defer</code>属性，相当于告诉浏览器该脚本立即下载，但是延迟执行。</p> <p>情况一：<code>HTML</code>未解析完，<code>defer</code>脚本已经加载完成，等待<code>HTML</code>解析完成后，去执行脚本，脚本执行完毕后触发<code>DOMContentLoaded</code>事件。
<img src="/assets/test-defer1.png" alt="test-defer1"></p> <p>情况二：<code>HTML</code>解析完成后，<code>defer</code>脚本才加载完成，然后执行脚本，脚本执行完毕后触发<code>DOMContentLoaded</code>事件。
<img src="/assets/test-defer2.png" alt="test-defer2"></p> <p><strong><code>共同点：</code></strong></p> <ul><li>1、下载脚本时不会阻塞页面的加载（执行时会）</li> <li>2、只对外部脚本文件有效</li> <li>3、都在<code>load</code>事件之前执行完毕</li></ul></div> <h2 id="css阻塞页面加载么"><a href="#css阻塞页面加载么" class="header-anchor">#</a> css阻塞页面加载么？</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>css</code>为什么一般都要放在<code>head</code>中?
<code>css</code>的下载是异步的，不会阻塞<code>HTML</code>的解析(<code>DOM</code>树的构建)。但是会阻塞页面的渲染。</p> <p>把<code>CSS</code>放在<code>head</code>中是为了防止加载出来的页面没有样式，看起来丑，然后样式加载完成后闪一下。好处在于加载出来的页面直接就是带有样式的，但是在页面未显示之前页面是白屏状态。</p> <p>页面展示流程：</p> <ul><li>1、渲染进程解析<code>HTML</code>，计算<code>DOM</code>结构，生成<code>DOM Tree</code>。</li> <li>2、解析<code>HTML</code>时，遇到<code>CSS</code>，会异步下载并解析，生成<code>Style Rules</code>，不会阻塞<code>HTML</code>的解析。</li> <li>3、解析<code>HTML</code>时，遇到<code>script（不带defer、async属性）</code>，会停止<code>HTML</code>的解析，开始下载并执行脚本，直到执行完成之后，继续解析<code>HTML</code>。</li> <li>4、合并<code>DOM Ttree</code> 和 <code>Style rules</code> 生成<code>render Tree(渲染树)</code></li> <li>5、根据<code>render</code>树（重绘和回流<code>Layout/reflow</code>）开始进行元素布局，负责各元素尺寸、位置的计算</li> <li>6、绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</li> <li>7、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ul></div> <h2 id="es6解构赋值、默认值"><a href="#es6解构赋值、默认值" class="header-anchor">#</a> ES6解构赋值、默认值</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">move1</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">move1</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// [0,0]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">move1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [0,0]</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>为什么两道题都是<code>[0,0]</code>?
如果没有传值，则给的默认值是空对象<code>{}</code>，然后再对值进行解构，那么传参数<code>{}</code>和不传应该是一样的结果，因为默认值是<code>{}</code>。然后解构，空对象中没有<code>x，y</code>，则取<code>x，y</code>的默认值<code>0,0</code>，所以结果是<code>[0,0]</code>。</p></div> <h2 id="滚动条滚动会导致回流么"><a href="#滚动条滚动会导致回流么" class="header-anchor">#</a> 滚动条滚动会导致回流么？</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>滚动条滚动时对于非<code>Fixed</code>定位的元素，是不会回流的。但是对于<code>Fixed</code>定位的元素，在滚动条滚动的时候是会一直回流的。</p></div> <h2 id="服务端渲染原理"><a href="#服务端渲染原理" class="header-anchor">#</a> 服务端渲染原理</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>服务端渲染意思是首屏页面中<code>HTML</code>中的内容是在后端<code>(node)</code>插入到<code>HTML</code>当中的，然后返回给前端直接进行渲染的。
用<code>webpack</code>打包出两份代码，一份服务端的，一份客户端可以直接访问的。其中，服务端打包出的<code>HTML</code>的<code>body</code>元素中只有一个占位符和需要引入客户端<code>js</code>一个<code>script</code>标签，以便在<code>node</code>服务器渲染出需要展示的内容之后，插入到<code>body</code>元素当中。然后返回给客户端，客户端就可以直接展示内容了。</p> <p>打包服务端<code>js</code>时，因为需要给<code>node</code>端使用，所以需要改为<code>node</code>端导入导出方式，这样才能在<code>node</code>端导入。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">output</span><span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token literal-property property">libraryTarget</span><span class="token operator">:</span> <span class="token string">'commonjs2'</span> <span class="token comment">// 打包出的js会在外部包上 module.exports导出</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是只有要展示的内容，所有的事件以及<code>JS</code>功能都是不生效的。所以，我们需要把打包出来的客户端代码中的<code>js</code>部分，采用<code>ejs</code>模板的方式注入到后端渲染的<code>HTML</code>中，这样就带有<code>JS</code>功能了(在打包的时候就直接配置即可)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpacl.server.js</span>
<span class="token literal-property property">plugins</span><span class="token operator">:</span><span class="token punctuation">[</span>
  <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">template</span><span class="token operator">:</span> xxxx<span class="token punctuation">,</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span><span class="token string">'server.html'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">minify</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">client</span><span class="token operator">:</span> <span class="token string">'/client.bundle.js'</span> <span class="token comment">// 需要注入js文件的名</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 占位符 --&gt;</span>

  <span class="token comment">&lt;!-- 采用ejs模板方式，将客户端打包出的js 注入到HTML中 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>&lt;%=htmlWebpackPlugin.options.client%&gt;<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这样就实现了服务端渲染，而且还带有<code>JS</code>功能的<code>HTML</code>了。</p></div> <h2 id="移动端实现1px"><a href="#移动端实现1px" class="header-anchor">#</a> 移动端实现1px</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>1px</code> 的边框。在高清屏下，移动端的<code>1px</code>会很粗
为什么移动端会有<code>1px</code>的问题？
一般多倍的屏幕设计图设计了1px的边框，在手机上缩小呈现时，由于css最低只支持显示<code>1px</code>大小，导致边框太粗的效果，实际是一种视觉差，并非<code>1px</code>真的变粗了。</p> <ul><li>1、使用伪元素 + <code>border</code> + <code>transform:scale</code><div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.div::after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200%<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #bfbfbf<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>
  <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">,</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">,</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">-webkit-transform-origin</span><span class="token punctuation">:</span> top left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>2、使用<code>box-shadow</code>模拟边框，利用<code>css</code>对阴影处理的方式实现<code>0.5px</code>的效果
缺点：阴影导致的颜色变浅，而且仔细看谁都看得出这是阴影而不是边框。。。<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.box-shadow-1px</span> <span class="token punctuation">{</span>
  <span class="token property">box-shadow</span><span class="token punctuation">:</span> 0  -1px 1px -1px #e5e5e5<span class="token punctuation">,</span>  //上边线
          1px  0  1px -1px #e5e5e5<span class="token punctuation">,</span>   //右边线
          0  1px  1px -1px #e5e5e5<span class="token punctuation">,</span>   //下边线
          -1px 0  1px -1px #e5e5e5<span class="token punctuation">;</span>   //左边线
<span class="token punctuation">}</span>
</code></pre></div></li> <li>3、采用<code>background-image &amp;&amp; boder-image</code>解决
缺点：换个颜色还得换图,而且图片处理圆角会出现模糊的问题<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.background-image-1px</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>...<span class="token punctuation">)</span></span> no-repeat left bottom<span class="token punctuation">;</span>
  <span class="token property">-webkit-background-size</span><span class="token punctuation">:</span> 100% 1px<span class="token punctuation">;</span>
  <span class="token property">background-size</span><span class="token punctuation">:</span> 100% 1px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.border-bottom-1px</span> <span class="token punctuation">{</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 0 0 1px 0<span class="token punctuation">;</span>
  <span class="token property">-webkit-border-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>...<span class="token punctuation">)</span></span> 0 0 2 0 stretch<span class="token punctuation">;</span>
  <span class="token property">border-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>...<span class="token punctuation">)</span></span> 0 0 2 0 stretch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>4、采用<code>viewport + rem</code>
页面初始化时，引入下面的标签。<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>WebViewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div>接下来就是通过<code>js</code>动态的修改缩放比，以及实现<code>rem</code>根元素字体大小的设置<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> viewport <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;meta[name=viewport]&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>devicePixelRatio <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  viewport<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>devicePixelRatio <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  viewport<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>devicePixelRatio <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  viewport<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> docEl <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">;</span>
<span class="token keyword">var</span> fontsize <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token punctuation">(</span>docEl<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token number">320</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
docEl<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> fontsize<span class="token punctuation">;</span>
</code></pre></div></li></ul></div> <h2 id="vue中运行时和完整版的区别"><a href="#vue中运行时和完整版的区别" class="header-anchor">#</a> vue中运行时和完整版的区别</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>vue</code>的完整版是带有编译器的，运行时的版本是不带编译器的，相比完整版体积减小了30%。如果没有编译器，你在<code>vue</code>中写的<code>template:'&lt;div&gt;  &lt;/div&gt;'</code>就无法转化为原始的<code>html</code>。与其在客户端编译，为什么不在打包的时候就编译好再发给用户呢？这样就节省了引入包的体积。
运行时版本是不需要编译器的，他是通过在打包的时候就使用<code>vue-loader</code>将<code>vue</code>文件转换为<code>h</code>函数所需要的参数</p></div> <h2 id="xss攻击"><a href="#xss攻击" class="header-anchor">#</a> XSS攻击</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p> <p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p> <p>XSS 一般分为存储型、反射型和 DOM 型。</p> <p>存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</p> <p>反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。</p> <p>DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。</p> <p>XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</p> <p>对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。</p> <p>因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p> <p>还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p> <p>还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/25/2022, 8:32:52 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/" class="prev router-link-active">
        常用技巧总结
      </a></span> <span class="next"><a href="/test/vue.html">
        Vue面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.acb235b1.js" defer></script><script src="/assets/js/2.d372d77b.js" defer></script><script src="/assets/js/1.37fa4b6c.js" defer></script><script src="/assets/js/98.b1d996fc.js" defer></script>
  </body>
</html>
