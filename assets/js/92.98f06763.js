(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{408:function(t,e,v){"use strict";v.r(e);var _=v(25),c=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#一-web-ui-中-dom-节点跨层级的移动操作特别少-可以忽略不计。"}},[t._v("一：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")])]),e("li",[e("a",{attrs:{href:"#二-component-diff"}},[t._v("二：component diff")])]),e("li",[e("a",{attrs:{href:"#三-element-diff"}},[t._v("三：element diff")])])])]),e("p"),t._v(" "),e("h1",{attrs:{id:"react之domdiff策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react之domdiff策略"}},[t._v("#")]),t._v(" React之domdiff策略")]),t._v(" "),e("h2",{attrs:{id:"一-web-ui-中-dom-节点跨层级的移动操作特别少-可以忽略不计。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-web-ui-中-dom-节点跨层级的移动操作特别少-可以忽略不计。"}},[t._v("#")]),t._v(" 一：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1、"),e("code",[t._v("React")]),t._v("对树的算法进行了优化，对树进行分层比较，两棵树只会对同一层次的节点进行比较：只会对相同层级的"),e("code",[t._v("DOM")]),t._v("节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较；这样只需要对树进行一次遍历，便能完成整个"),e("code",[t._v("DOM")]),t._v("树的比较")])]),t._v(" "),e("li",[e("p",[t._v("2、当出现了"),e("code",[t._v("DOM")]),t._v("节点跨层级的移动操作，domdiff会怎么做？\n"),e("img",{attrs:{src:t.$withBase("/assets/react-4-1.png"),alt:"react-4-1"}})]),t._v(" "),e("p",[t._v("当出现节点跨层级移动时，并不会出现我们所想象的移动操作，而是以A为根节点的整个树被重新创建。这是一种影响"),e("code",[t._v("React")]),t._v("性能的操作 ，因此官方建议不要进行"),e("code",[t._v("DOM")]),t._v("节点跨层级的操作；")])])])]),t._v(" "),e("h2",{attrs:{id:"二-component-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-component-diff"}},[t._v("#")]),t._v(" 二：component diff")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("ul",[e("li",[t._v("1、如果是同一类型的组件，按照原策略继续比较虚拟"),e("code",[t._v("DOM")]),t._v("树即可；")]),t._v(" "),e("li",[t._v("2、如果不是，则将该组件判断为"),e("code",[t._v("dirty component")]),t._v("，从而替换整个组件下的所有子节点；")]),t._v(" "),e("li",[t._v("3、对于同一类型的组件，有可能其虚拟"),e("code",[t._v("DOM")]),t._v("没有发生任何变化，如果能够确切知道这点，那么就可以节省大量的"),e("code",[t._v("diff")]),t._v("运算时间，因此，"),e("code",[t._v("React")]),t._v("允许用户通过"),e("code",[t._v("shouldComponentUpdate()")]),t._v("生命周期函数来判断组件是否需要进行"),e("code",[t._v("diff")]),t._v("算法分析；\n"),e("ul",[e("li",[t._v("如：通过三元运算符判断展示对应组件的时候，当"),e("code",[t._v("D")]),t._v("组件变为"),e("code",[t._v("G")]),t._v("组件时，即使这两个组件结构相似，一旦"),e("code",[t._v("react")]),t._v("判断"),e("code",[t._v("D")]),t._v("和"),e("code",[t._v("G")]),t._v("是不同类型的组件，就不会比较二者的结构，而是直接删除组件"),e("code",[t._v("D")]),t._v("，重新创建组件"),e("code",[t._v("G")]),t._v("及其子节点。")]),t._v(" "),e("li",[e("img",{attrs:{src:t.$withBase("/assets/react-4-2.png"),alt:"react-4-2"}})])])])])]),t._v(" "),e("h2",{attrs:{id:"三-element-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-element-diff"}},[t._v("#")]),t._v(" 三：element diff")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("当节点处于同一层级时，diff提供了三种节点操作,分别为")]),t._v(" "),e("ul",[e("li",[t._v("1、"),e("code",[t._v("INSERT_MARKUP")]),t._v("(插入)：\n"),e("ul",[e("li",[t._v("当新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作；")])])]),t._v(" "),e("li",[t._v("2、"),e("code",[t._v("MOVE_EXISTING")]),t._v(" (移动);\n"),e("ul",[e("li",[t._v("旧集合中有新组件类型，且"),e("code",[t._v("element")]),t._v("是可更新的类型，这种情况下，就需要做移动操作，可以复用以前的"),e("code",[t._v("DOM")]),t._v("节点；")])])]),t._v(" "),e("li",[t._v("3、"),e("code",[t._v("REMOVE_NODE")]),t._v("(删除);\n"),e("ul",[e("li",[t._v("旧组件类型，在新集合里也有，但对应的 "),e("code",[t._v("element")]),t._v(" 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。")])])])]),t._v(" "),e("img",{attrs:{src:t.$withBase("/assets/react-4-3.png"),alt:"react-4-3"}}),t._v(" "),e("p",[e("code",[t._v("React")]),t._v("发现这类操作烦琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可；")]),t._v(" "),e("p",[t._v("针对这一现象，"),e("code",[t._v("React")]),t._v("提出了优化策略：允许开发者对同一层级的同组子节点，添加唯一"),e("code",[t._v("key")]),t._v("进行区分，这样在性能上就发生了翻天覆地的提升；")]),t._v(" "),e("p",[t._v("新旧集合所包含的节点如图 3-22 所示，进行 "),e("code",[t._v("diff")]),t._v(" 差异化对比后，通过 "),e("code",[t._v("key")]),t._v(" 发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置，此时 "),e("code",[t._v("React")]),t._v(" 给出的 "),e("code",[t._v("diff")]),t._v(" 结果为："),e("code",[t._v("B、D")]),t._v(" 不做任何操作，"),e("code",[t._v("A、C")]),t._v(" 进行移动操作即可。")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/assets/react-4-4.png"),alt:"react-4-4"}})])])}),[],!1,null,null,null);e.default=c.exports}}]);