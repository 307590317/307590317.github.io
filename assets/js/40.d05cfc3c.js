(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{356:function(t,v,_){"use strict";_.r(v);var e=_(25),o=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#宽度计算"}},[t._v("宽度计算")])]),v("li",[v("a",{attrs:{href:"#为什么不能垂直居中"}},[t._v("为什么不能垂直居中？")])])])]),v("p"),t._v(" "),v("h1",{attrs:{id:"_4、为何auto可以实现水平居中"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、为何auto可以实现水平居中"}},[t._v("#")]),t._v(" 4、为何"),v("code",[t._v("auto")]),t._v("可以实现水平居中")]),t._v(" "),v("h2",{attrs:{id:"宽度计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宽度计算"}},[t._v("#")]),t._v(" 宽度计算")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("默认的宽度计算规则是“适应于父级”规则")]),t._v(" "),v("p",[v("code",[t._v("W3C css 2.1")]),t._v("第十章里为常规流替换和非替换块元素定义了这个算式：\n"),v("code",[t._v("margin-left")]),t._v(" + "),v("code",[t._v("border-left-width")]),t._v(" + "),v("code",[t._v("padding-left")]),t._v(" + "),v("code",[t._v("width")]),t._v(" + "),v("code",[t._v("padding-right")]),t._v(" + "),v("code",[t._v("border-right-width")]),t._v(" + "),v("code",[t._v("margin-right")]),t._v(" = "),v("code",[t._v("width of containing block")])]),t._v(" "),v("p",[t._v("同时为几项"),v("code",[t._v("auto")]),t._v("设置了额外的算法：\n"),v("code",[t._v("If there is exactly one value specified as 'auto', its used value follows from the equality.")]),t._v(" "),v("code",[t._v("If 'width' is set to 'auto', any other 'auto' values become '0' and 'width' follows from the resulting equality.")])]),t._v(" "),v("p",[t._v("如果"),v("code",[t._v("width")]),t._v("值被设置为 "),v("code",[t._v("auto")]),t._v(" 值，那么其它属性是 "),v("code",[t._v("auto")]),t._v(" 的值就为 0.")]),t._v(" "),v("p",[v("code",[t._v("If both 'margin-left' and 'margin-right' are 'auto', their used values are equal. This horizontally centers the element with respect to the edges of the containing block.")])]),t._v(" "),v("p",[t._v("第二条：所以说 "),v("code",[t._v("width: auto")]),t._v("， "),v("code",[t._v("margin: auto")]),t._v(" 的时候啊，"),v("code",[t._v("margin")]),t._v(" 就为 "),v("code",[t._v("0")]),t._v(" 了\n整个容器充满包含块呗。也就没水平居中啥事儿了。")]),t._v(" "),v("p",[t._v("第三条：如果"),v("code",[t._v("margin-left")]),t._v("和"),v("code",[t._v("margin-right")]),t._v("的值都为"),v("code",[t._v("auto")]),t._v("，使用相等的值，那么水平居中包含块")]),t._v(" "),v("p",[t._v("如果"),v("code",[t._v("width")]),t._v("为"),v("code",[t._v("auto")]),t._v("，那么"),v("code",[t._v("ml/mr")]),t._v("中"),v("code",[t._v("auto")]),t._v("值将变为"),v("code",[t._v("0")]),t._v("后面的"),v("code",[t._v("if")]),t._v("不再生效")]),t._v(" "),v("p",[t._v("如果"),v("code",[t._v("width")]),t._v("值不为"),v("code",[t._v("auto")]),t._v("，"),v("code",[t._v("ml/mr")]),t._v("值为"),v("code",[t._v("auto")]),t._v("，那么此包含块居中显示；")]),t._v(" "),v("p",[t._v("对于绝对定位元素，有以下算式：\n"),v("code",[t._v("left")]),t._v(" + "),v("code",[t._v("margin-left")]),t._v(" + "),v("code",[t._v("border-left-width")]),t._v("  + "),v("code",[t._v("padding-left")]),t._v(" + "),v("code",[t._v("width")]),t._v(" + "),v("code",[t._v("padding-right")]),t._v(" + "),v("code",[t._v("border-right-width")]),t._v(" + "),v("code",[t._v("margin-right")]),t._v("  + "),v("code",[t._v("right")]),t._v("  = "),v("code",[t._v("width of containing block")])]),t._v(" "),v("p",[t._v("加入了"),v("code",[t._v("left")]),t._v("和"),v("code",[t._v("right")]),t._v("，可以用类似的方式达到水平居中")])]),t._v(" "),v("h2",{attrs:{id:"为什么不能垂直居中"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能垂直居中"}},[t._v("#")]),t._v(" 为什么不能垂直居中？")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("高度计算")]),t._v(" "),v("p",[t._v("默认行为的高度计算则是一系列“撑高”规则，而非“适应于父级”规则。\n"),v("code",[t._v("width")]),t._v("相关计算依赖于其包含块，这玩意是最初能确定的值，而"),v("code",[t._v("height")]),t._v("相关计算依赖于其自身内容高度，由于数据数量不确定，所以自身内容高度是不能最初确定值的，所以无法建立类似的公式来使用"),v("code",[t._v("mt、mb auto")]),t._v("来实现高度居中。")])])])}),[],!1,null,null,null);v.default=o.exports}}]);